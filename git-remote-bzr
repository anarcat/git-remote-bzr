#!/usr/bin/env python

import sys
import os
sys.path.insert(0, os.getenv("GITPYTHONLIB","."))

import bzrlib.branch

from git_remote_helpers.util import die, debug, warn, start_command, run_command
from git_remote_helpers.git.repo import GitRepo
from git_remote_helpers.git.exporter import GitExporter
from git_remote_helpers.git.importer import GitImporter
from git_remote_helpers.git.non_local import NonLocalGit



class Bzr(object):
    def __init__(self, alias, url):
        self.alias = alias
        self.url = url

    def get_branch(self):
        try:
            return bzrlib.branch.Branch.open(self.url)
        except Exception, e:
            die('Could not open branch at %s : %s' % (self.url, e))

    branch = property(fget=get_branch)

#def local_repo(repo, path):
#    """Returns a git repository object initalized for usage.
#    """
#
#    local = GitRepo(path)
#
#    local.non_local = None
#    local.gitdir = repo.gitdir
#    local.alias = repo.alias
#    local.prefix = repo.prefix
#    local.hash = repo.hash
#    local.get_base_path = repo.get_base_path
#    local.exporter = GitExporter(local)
#    local.importer = GitImporter(local)
#
#    return local


def do_capabilities(repo, args):
    """Prints the supported capabilities.
    """

    print "fetch"
    ##print "import"
    ##print "export"
    ##print "gitdir"
    ##print "refspec refs/heads/*:%s*" % repo.prefix

    print # end capabilities


def do_list(repo, args):
    """Lists all known references.
    """

    branch = repo.get_branch()

##    for ref in branch.revision_history():
##        debug("? %s", ref)
##        print "? %s" % ref
##
##    headname = branch.last_revision()
##    if headname != 'NULL_REVISION':
##        debug("@%s HEAD" % headname)
##        print "@%s HEAD" % headname
    # FIXME replace by actual branch name
    print "? refs/heads/master"

    ##for ref in repo.revs:
    ##    debug("? refs/heads/%s", ref)
    ##    print "? refs/heads/%s" % ref

    ##if repo.head:
    ##    debug("@refs/heads/%s HEAD" % repo.head)
    ##    print "@refs/heads/%s HEAD" % repo.head
    ##else:
    ##    debug("@refs/heads/master HEAD")
    ##    print "@refs/heads/master HEAD"

    print # end list


#def update_local_repo(repo):
#    """Updates (or clones) a local repo.
#    """
#
#    if repo.local:
#        return repo
#
#    path = repo.non_local.clone(repo.gitdir)
#    repo.non_local.update(repo.gitdir)
#    repo = local_repo(repo, path)
#    return repo

def fetch_one(repo, rev_id):
    """Imports a single revision and write it

    The object hash of the revision is returned.
    """
    #import rpdb2
    #rpdb2.start_embedded_debugger('assword')

    # write rev blobs
    tree = repo.branch.repository.revision_tree(rev_id)
    tree.lock_read()
    try:
        for file_id in tree.all_file_ids():
            content = tree.get_file(file_id).read()
            if not content:
                continue
            command = start_command(args=['git', 'hash-object',
                                          '--stdin',
                                          '-t', 'blob',
                                          '-w',
                                         ])
            output, errors = command.communicate(content)
            sha1 = output.strip('\n')
    finally:
        tree.unlock()

    # write rev trees
    # TODO

    # write commit
    # TODO

    return sha1


def do_fetch(repo, args):
    """Fetch the given object, writing it to the database
    """
    if len(args) != 2:
        die("Fetch needs exactly one sha1 and one name")

    # TODO Fetch first revision, for now
    first = repo.branch.revision_history()[0]
    sha1 = fetch_one(repo, first)

    # TODO update refs with correct refname and rev hash
    run_command(['git', 'update-ref', 'refs/remotes/origin/master', sha1])

    # print blank line when done
    print ""

def do_import(repo, args):
    """Exports a fast-import stream from testgit for git to import.
    """

    if len(args) != 1:
        die("Import needs exactly one ref")

    #if not repo.gitdir:
    #    die("Need gitdir to import")

    x = 42
#    repo = update_local_repo(repo)
#    repo.exporter.export_repo(repo.gitdir)


def do_export(repo, args):
    """Imports a fast-import stream from git to bzr.
    """

    if not repo.gitdir:
        die("Need gitdir to export")

#    dirname = repo.get_base_path(repo.gitdir)

    if not os.path.exists(dirname):
        os.makedirs(dirname)

#    path = os.path.join(dirname, 'testgit.marks')
#    print path
#    print path if os.path.exists(path) else ""
#    sys.stdout.flush()
#
#    update_local_repo(repo)
#    repo.importer.do_import(repo.gitdir)
#    repo.non_local.push(repo.gitdir)


def do_gitdir(repo, args):
    """Stores the location of the gitdir.
    """

    if not args:
        die("gitdir needs an argument")

    repo.gitdir = ' '.join(args)


COMMANDS = {
    'capabilities': do_capabilities,
    'list': do_list,
    'import': do_import,
    'export': do_export,
    'gitdir': do_gitdir,
    'fetch': do_fetch,
}


def sanitize(value):
    """Cleans up the url.
    """

    if value.startswith('bzr::'):
        value = value[5:]

    return value


def read_one_line(repo):
    """Reads and processes one command.
    """

    line = sys.stdin.readline()

    cmdline = line

    if not cmdline:
        warn("Unexpected EOF")
        return False

    cmdline = cmdline.strip().split()
    if not cmdline:
        # Blank line means we're about to quit
        return False

    cmd = cmdline.pop(0)
    debug("Got command '%s' with args '%s'", cmd, ' '.join(cmdline))

    if cmd not in COMMANDS:
        die("Unknown command, %s", cmd)

    func = COMMANDS[cmd]
    func(repo, cmdline)
    sys.stdout.flush()

    return True


def main(args):
    """Starts a new remote helper for the specified repository.
    """

    if len(args) != 3:
        die("Expecting exactly three arguments.")
        sys.exit(1)

    if os.getenv("GIT_DEBUG_BZR"):
        import git_remote_helpers.util
        git_remote_helpers.util.DEBUG = True

    alias = sanitize(args[1])
    url = sanitize(args[2])

    if not alias.isalnum():
        warn("non-alnum alias '%s'", alias)
        alias = "tmp"

    args[1] = alias
    args[2] = url

    repo = Bzr(alias, url)

    debug("Got arguments %s", args[1:])

    more = True

    while (more):
        more = read_one_line(repo)

if __name__ == '__main__':
    sys.exit(main(sys.argv))
